#ifndef SAFE_TELEOP_CORE_INTERFACES_HPP
#define SAFE_TELEOP_CORE_INTERFACES_HPP

#include <memory>
#include <string>
#include <vector>

#include <sensor_msgs/msg/image.hpp>
#include <sensor_msgs/msg/camera_info.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <geometry_msgs/msg/pose.hpp>
#include <geometry_msgs/msg/twist.hpp>

// Forward declarations for custom messages (will be generated by ROS2)
namespace safe_teleop_core {
namespace msg {
    class CollisionWarning;
    class SafetyZone;
    class ObjectStatus;
    class DynamicObject;
}
}

namespace safe_teleop_core {

/**
 * @brief Camera interface for multi-camera support (SOLID: OCP, LSP)
 *
 * Allows swapping between RealSense D405, ZED Mini, or simulated cameras
 * without changing the core perception logic.
 */
class CameraInterface {
public:
    virtual ~CameraInterface() = default;

    /**
     * @brief Get RGB image from camera
     * @return Shared pointer to RGB image message
     */
    virtual sensor_msgs::msg::Image::SharedPtr get_rgb() = 0;

    /**
     * @brief Get depth image from camera
     * @return Shared pointer to depth image message
     */
    virtual sensor_msgs::msg::Image::SharedPtr get_depth() = 0;

    /**
     * @brief Get camera intrinsics
     * @return Shared pointer to camera info message
     */
    virtual sensor_msgs::msg::CameraInfo::SharedPtr get_camera_info() = 0;

    /**
     * @brief Get camera frame ID for TF transforms
     * @return Frame ID string (e.g., "camera_link")
     */
    virtual std::string get_frame_id() const = 0;

    /**
     * @brief Check if camera is ready and publishing data
     * @return True if camera is operational
     */
    virtual bool is_ready() const = 0;
};

/**
 * @brief Safety checker interface for collision detection (SOLID: OCP, ISP)
 *
 * Allows different safety checking strategies:
 * - ESDF-based (high precision)
 * - Point Cloud-based (local fallback)
 * - Hybrid (combining both)
 */
class SafetyCheckerInterface {
public:
    virtual ~SafetyCheckerInterface() = default;

    /**
     * @brief Check collision risk for given robot pose
     * @param robot_pose Current or predicted robot pose
     * @return CollisionWarning message with severity and recommended action
     */
    virtual msg::CollisionWarning check_collision(
        const geometry_msgs::msg::Pose& robot_pose) = 0;

    /**
     * @brief Check collision for robot trajectory
     * @param trajectory Vector of waypoints to check
     * @return Vector of collision warnings for each waypoint
     */
    virtual std::vector<msg::CollisionWarning> check_trajectory(
        const std::vector<geometry_msgs::msg::Pose>& trajectory) = 0;

    /**
     * @brief Get current safety margin in meters
     * @return Safety margin value
     */
    virtual double get_safety_margin() const = 0;

    /**
     * @brief Set safety margin (can be increased for dynamic objects)
     * @param margin New safety margin in meters
     */
    virtual void set_safety_margin(double margin) = 0;

    /**
     * @brief Get the current safety mode
     * @return Mode string ("NORMAL", "DEGRADED", "EMERGENCY")
     */
    virtual std::string get_safety_mode() const = 0;
};

/**
 * @brief ESDF query interface for distance field operations (SOLID: ISP)
 *
 * Minimal interface for querying Euclidean Signed Distance Field
 */
class ESDFInterface {
public:
    virtual ~ESDFInterface() = default;

    /**
     * @brief Query distance to nearest obstacle at given point
     * @param point 3D point in world frame
     * @return Distance in meters (negative = inside obstacle)
     */
    virtual double query_distance(const geometry_msgs::msg::Point& point) const = 0;

    /**
     * @brief Check if ESDF data is available and fresh
     * @param max_age_sec Maximum acceptable age of ESDF data in seconds
     * @return True if ESDF is valid and recent
     */
    virtual bool is_valid(double max_age_sec = 1.0) const = 0;

    /**
     * @brief Get timestamp of last ESDF update
     * @return Timestamp in seconds since epoch
     */
    virtual double get_last_update_time() const = 0;
};

/**
 * @brief Object manager interface for activation/deactivation (SOLID: SRP)
 *
 * Manages which objects the robot is allowed to interact with
 */
class ObjectManagerInterface {
public:
    virtual ~ObjectManagerInterface() = default;

    /**
     * @brief Activate object (allow robot contact)
     * @param object_id Unique identifier for object
     * @return True if activation successful
     */
    virtual bool activate_object(const std::string& object_id) = 0;

    /**
     * @brief Deactivate object (prohibit robot contact)
     * @param object_id Unique identifier for object
     * @return True if deactivation successful
     */
    virtual bool deactivate_object(const std::string& object_id) = 0;

    /**
     * @brief Check if object is currently active
     * @param object_id Unique identifier for object
     * @return True if object is active
     */
    virtual bool is_object_active(const std::string& object_id) const = 0;

    /**
     * @brief Get status of all tracked objects
     * @return Vector of ObjectStatus messages
     */
    virtual std::vector<msg::ObjectStatus> get_all_objects() const = 0;
};

} // namespace safe_teleop_core

#endif // SAFE_TELEOP_CORE_INTERFACES_HPP
